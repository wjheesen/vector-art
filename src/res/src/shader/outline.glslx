precision mediump float;

uniform mat4 projection;         // Projection matrix (maps from world space to clip space)
uniform vec4 color;              // Color of outline
uniform float lineWidth;         // Width of lines making up outline
attribute mat2 model;            // Model matrix (maps from model space to world space)
attribute vec2 offset;           // Third column of model matrix
attribute vec2 position;         // Position of current vertex in model space
attribute vec2 miter;            // The miter to apply to this vertex

mat2 rotation(float radians){
    float sin = sin(radians);
    float cos = cos(radians);
    return mat2(cos,sin,-sin,cos);
}

export void vertex(){

    // Extract rotation angle from model matrix
    float a = model[0][0];
    float b = model[1][0];
    float c = model[0][1];
    float d = model[1][1];

    float e = (a + d) / 2.0;
    float f = (a - d) / 2.0;
    float g = (c + b) / 2.0;
    float h = (c - b) / 2.0;

    float q = sqrt(e*e + h*h);
    float r = sqrt(f*f + g*g);

    float a1 = atan(g,f);
    float a2 = atan(h,e);

    float theta = (a2 - a1) / 2.0;
    float phi = (a2 + a1) / 2.0;

    mat2 u = rotation(phi);
    mat2 v = rotation(theta);

    // // 
    vec2 rotatedMiter = /*rotation(phi+theta) **/ u * (lineWidth * (v * miter));

    // Add miter to world position
    vec2 worldPosition = (model * position) + offset + rotatedMiter;
    gl_Position = projection * vec4(worldPosition, 1.0, 1.0);
}

export void fragment(){
    gl_FragColor = color;
}

